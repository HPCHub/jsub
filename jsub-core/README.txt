Jsub. Атоматизированное выполнение пайп-лайнов.


!!! Данное руководство не претендует на полноту. Критика и дополнения в сторону документации и работы программы приветствуется !!!


1. Введение.
2. Основные понятия и терминология.
 2.1. Макет.
  2.1.1. Свойства.
  2.1.1. Скрипт.
 2.2. Сценарий.
 2.3. Проект.
3. Создание проекта.
4. Отладка и запуск проекта.
5. Как писать скрипты.


1. Введение.

Jsub - программа для запуска последовательности задач. Названа по аналогии с qsub - стандартной тулсой для постановки задач в очередь планировщика OGE. Буква "j" означает, что программа написана на Java. Основное (и пока что единственное) отличае от qsub, заключает в том, что jsub, отправляет задачи в очередь по заранее определённому сценарию. Сценарий представляет из себя xml-файл. Jsub находится в директории /data3/bio/biouser/tools/jsub. Для того, чтобы запустить программу необходимо выполнить скрипт /data3/bio/biouser/tools/jsub/scripts/jsub.production.sh.
Возможно настанут лучшие времена и мы соберём jsub в rpm пакет, так, что для программу можно будет вызвать просто напечатав jsub в консоли. На данный момент в качестве альтернативы могу предложить следующее - создать директорию bin в домашней папке, а из неё символическую ссылку на скрипт:
cd ~
mkdir bin
ln -s /data3/bio/biouser/tools/jsub/scripts/jsub.production.sh jsub


2. Основные понятия и терминология.

 Сценарий - xml-файл, содержащий последовательность задач, которые необходимо выполнить в рамках одного проекта.
 Проект - совокупность данных, сценария и директории в которой над данными будет выполнен ряд вычислений, описанных в сценарии.
 Задача/таска/цель - состовляющая сценария и описывающее одно его действие.
 Макет - файловая структура одного конкретного проекта.
 
 Всё расмотренное ниже будет приводится на основе проекта "метагеном".


 2.1. Макет.

  Макет представляет собой структурное описание проекта в файловой системе. Все макеты хранятся в директории /data3/bio/biouser/tools/conveyor/layout. Как видно на данный момент там есть макеты для метагенома и транскриптома (мха). Всё что находится в директории макета, будет скопировано в директорию проекта при его создании. Обязательными для каждого макета являются файлы build.xml и build.properties. build.xml содержит сценарий проекта, build.properties - конфигурацию проекта.
 
 
 2.2. Сценарий.
  
  Каждый сценарий имеет следующую струтуру:
  ========================================
  <?xml version="1.0" encoding="UTF-8"?>
  <project name="metagenome">

	<taskdef resource="net/sf/antcontrib/antcontrib.properties">
		<classpath>
			<pathelement location="${ant.contrib.path}" />
		</classpath>
	</taskdef>

	<target name="saet">
		<property name="input.csfasta.file" value="${input.csfasta.file}" />
		<property name="input.qual.file" value="${input.qual.file}" />
		<propertyregex property="output.csfasta.file" input="${input.csfasta.file}" regexp="^(.*)\.(.*)$" select="\1.fixed.\2" />
	</target>

	<target name="qv-trimming" depends="saet">
		<property name="input.csfasta.file" value="${input.csfasta.file}" />
		<property name="input.qual.file" value="${input.qual.file}" />
		<propertyregex property="output.csfasta.file" input="${input.csfasta.file}" regexp="^(.*)\.(.*)$" select="\1.trimmed.\2" />
	</target>

  </project>
  ========================================  
  Корневой элемент каждого проекта project. Project должен иметь обязательный параметр name и содержать в качестве дочерних тэгов только taskdef и target. Аттрибут name тэга project должен совпадать с названием директории соответствующего макета. taskdef обязательный служебный тэг, от которого мы когда нибудь избавимся. Taget - элемент, который описывает отдельную задачу сценария. Это и есть задача/таска/цель. Каждый элемент target описывает задачу как чёрный ящик. Он должен содержать обязательный аттрибут name, уникальный в рамках project'а. Внутри тэга target допускается использование тэгов property и propertyregex. Эти тэги определяют какие параметры подаются на вход задаче, какие будут получены на выходе. Сама же задача представляет собой shell-скрипт, который хранится в директории /data3/bio/biouser/tools/conveyor/scripts/shell. Название скрипта совпадает с аттрибутом name тэга target.
  

    2.1.1. Свойства.

  Файл build.properties, который так же хранится в директории макета, содержит первоначальные свойства/опции проекта. Например:
  ========================================  
  input.csfasta.file=
  input.qual.file=
  input.fai-index.file=/data3/bio/metagenome/reference/HMP_2012_02/HMP_2012_02.fasta.fai
  input.fasta-index.file=/data3/bio/metagenome/reference/HMP_2012_02/HMP_2012_02.fasta
  ...
  ========================================
  В даннои случае видно, что ряд свойств не имеют значений, а другому ряду значения уже назначены. Это означает, что для проекта "метагеном" свойства input.fai-index.file и input.fasta-index.file всегда постоянны, а input.csfasta.file и input.qual.file следует заполнить пользователю, при создании проекта. На самом деле, никто не мешает отредактировать и существующие свойства и добавить новые.
  Имена свойств, которые подаются на вход проекту (задачам проекта) должны начинаться на "input.". Далее следует пояснение, и следом, как ни странно, ещё одно пояснение. Т.о. все свойства, которые представляют собой файлы, должны называться input.пояснение.file. Смысл в этом так же ещё и в том, что перед запуском проекта на выполнение будет проверено наличие указанных файлов в файловой системе. Все свойства из build.properties будут подставлены в (без явной замены) в build.xml не место плэйсхолдеров ${...}.


    2.1.1. Скрипт.

  Скрипты хранятся в директории /data3/bio/biouser/tools/conveyor/scripts/shell. Директория  Рассмотрим скрипт saet.sh:
  ========================================
  SCRIPT_NAME=$(basename "$BASH_SOURCE");
  echo "=> Start $SCRIPT_NAME";

  ### debug-section ####
  echo "input.csfasta.file=${input.csfasta.file}";
  echo "input.qual.file=${input.qual.file}";
  echo "output.csfasta.file=${output.csfasta.file}";
  ######################
  #
  #
  #
  #### exec-section ####
  fixedFileName=$(basename "${input.csfasta.file}");
  logFile="${project.build.dir}log/saet.log"

  ${saet.path} "${input.csfasta.file}" 200000000 -qual "${input.qual.file}" -qvupdate -trustprefix 25 -localrounds 3 -globalrounds 2 ${saet.thread} -log "$logFile"
  cp "$PWD/fixed/$fixedFileName" "${output.csfasta.file}"
  rm -r "$PWD/fixed";
  ######################

  echo "=> Stop $SCRIPT_NAME";
  ========================================
  В основе каждого скрипта лежит каркас из /data3/bio/biouser/tools/conveyor/template.sh. В нём определяется название скрипта и выводится информация о начале и окончании его работы. debug-section содержит отладочную информацию. exec-section - суть скрипта. Плэйсхолдеры ${...} будут явно заменены на значения свойств указанных в тэгах property и propertyregex.
  Вернёмся к build.xml и цели saet. Её передаётся на вход 3 параметра. Два input и одно output. Не взирая на то, что output по логике выходной параметр, его значение так же доступно в saet.sh.
  Значения input.csfasta.file и input.qual.file берутся из build.properties. output.csfasta.file - "синтетическое" свойство и синтетичность его заключается в том, что его значение вычисляется в рамках тэг propertyregex при помощи регулярного выражения. Например, если мы указали в build.properties, что input.csfasta.file=/home/zeleniy/projects/metagenome/1P_phi2_20120514_FRAG_BC/1P_phi2_20120514_FRAG_BC_1P_phi2_F3_6P.csfasta.15.filtered, то после "вычислений" в propertyregex, свойство output.csfasta.file будет равно /home/zeleniy/projects/metagenome/1P_phi2_20120514_FRAG_BC/1P_phi2_20120514_FRAG_BC_1P_phi2_F3_6P.csfasta.15.fixed.filtered (работать лучше с абсолютными путями).
  
  [Лирическое отступление:
    Если вы не знакомы с регулярными выражениями, то ничего страшного. В сцанариях их используется только несколько "видов":
    ... regexp="^(.*)\.(.*)$" select="\1.fixed.\2" /> заменит название файла с 1P_phi2_20120514_FRAG_BC_1P_phi2_F3_6P.csfasta.15.filtered на 1P_phi2_20120514_FRAG_BC_1P_phi2_F3_6P.csfasta.15.fixed.filtered
    ... regexp="^([^\.]*).*\.(.*)$" select="\1.human-unmapped.\2" /> заменит название файла с 1P_phi2_20120514_FRAG_BC_1P_phi2_F3_6P.csfasta.15.fixed.filtered на 1P_phi2_20120514_FRAG_BC_1P_phi2_F3_6P.human-unmapped.filtered
    ... regexp="^([^\.]*).*$" select="\1.sam" /> заменит название файла с 1P_phi2_20120514_FRAG_BC_1P_phi2_F3_6P.human-unmapped.filtered на 1P_phi2_20120514_FRAG_BC_1P_phi2_F3_6P.sam
  ]
  
  Задачи могут быть быть зависимыми и независимыми. Зависимость проявляется наличием аттрибута depends тэга tagret. Задачи которые не имеют зависимостей отправляются в планировщик задач OGE первыми. Задачи которые не имеют зависимостей, а так же задачи, которые имеют одинаковые зависимости выполняются параллельно. Задачи, у которых есть зависимости, не начнут выполняться до тех пор, пока не выполнятся задачи от которых они зависят. В нашем случае qv-trimming не начнёт выполнятся, пока не выполнится saet. Все output-св-ва из saet, превратяться в input-св-ва для qv-trimming. Т.о. qv-trimming будет работать не с файлом 1P_phi2_20120514_FRAG_BC_1P_phi2_F3_6P.csfasta.15.filtered, а с файлом 1P_phi2_20120514_FRAG_BC_1P_phi2_F3_6P.csfasta.15.fixed.filtered.


 2.3. Проект.
 
 Каждый проект имеет несколько фаз своего жизненного цикла:
  1. создание
  2. тестирование (конфигурационного файла)
  3. установка (скриптов из /data3/bio/biouser/tools/conveyor/scripts/shell)
  4. подготовка
  5. копирование исходных данных
  6. сборка
  7. запуск
 Пока не ясно нужно ли всё это и нужно ли всё это показывать пользователю :) Все это можно увидеть напечатав "jsub" в консоли.
 
 
3. Создание проекта.

Для создания проекта необходимо выполнить следующую команду:
jsub create --project.name 1P_phi2_20120514_FRAG_BC --project.type metagenome

Jsub, в текущей директории создаст папку metagenome, в ней 1P_phi2_20120514_FRAG_BC, в которой в свою очередь развернёт следующую структуру:
config/
  build.properties
  build.xml
log/
output/
scripts/

Директория config содержит build.xml и build.properties, скопированные из /data3/bio/biouser/tools/conveyor/layout/metagenome.
В директории scripts окажутся скрипты, после выполнеия команды install. В log будет лежать jsub.log, а также должны лежать все логи скриптов, в случае необходимости или неотвратимости их логирования. Так же там окажутся логи OGE о работе скриптов /scripts.
В директории output должны оказаться только те файлы, которые являются результатом работы сценария.
Фазы жизненного цикла так же зависят друг от друга, поэтому, например после создания проекта вызвав команду execute, jsub скорее всего выдаст ошибку, что вы не сконфигурили проект (если вы его, естественно не сконфигурили). Это связано с тем, что execute, среди прочих, зависит и от комманды test.


4. Отладка и запуск проекта.


Каждый проект, после того, как его отладили, можно запустить двумя способами:
jsub execute --project.name 1P_phi2_20120514_FRAG_BC --project.type metagenome
jsub queue --project.name 1P_phi2_20120514_FRAG_BC --project.type metagenome

execute - это запуск сценария в консольном режиме. Для этого вам не понадобится кластер - все задачи выполнятся последовательно друг за другом. Никакой паралелизации задач нет (пока, по крайней мере)
queue - это запуск сценария с использованием планировщика задач OGE. Вся работа jsub здесь заключается в том, чтобы считать файл сценария, создать скрипты задач и запихать всё это в планировщик. На этом jsub отваливается и за работу берётся планировщик и OGE.

Под отладкой понимается следующее:
 1. убедиться, что в скрипты правильно передаются значения св-в, а так же, что все плэйсхолдеры заменяются на соответствующие значения. Для этого, чтобы ускорить процесс, необходимо закоментировать весь код скрипта, который находится в exec-section.
 2. последовательно раскоментировать exec-section скриптов, запуская их отдельно друг от друга.
 3. запустить весь сценарий на выполнение командой execute.


5. Как писать скрипты.

Как уже говорилось, каждый скрипт должен писаться на основе template.sh. Т.к. скрипты в директории /data3/bio/biouser/tools/conveyor/scripts/shell доступны для редактирования всем пользователям, то там они лежат не самим по себе, а в виде рабочей копии svn. Это значит, что после того, как вы отладили новый сценарий, в консли, в директории /data3/bio/biouser/tools/conveyor/scripts/shell нужно выполнить команду:
svn commit -m "небольшой комментарий о том, что вы сделали"
Т.о. мы всегда сможем откатить нынешнее состояние скриптов, к предыдущему, если вы что то испортили в чьём то скрипте. Старайтесь писать скрипты либо максимально абстрактыми, в том смысле, чтобы их можно было применить в любом другом сценарии, либо сугубо специфичными, для ваших целей. Не стесняйтесь заполнять поле :description и описание входных и выходных параметров.
Каждый скрипт должен (очень желательно) представлять собой одну атомарную задачу.


!!! Данное руководство не претендует на полноту. Критика и дополнения в сторону документации и работы программы приветствуется !!!


